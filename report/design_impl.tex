\section{Design av løsningen}

	\subsection{Overordnet design (Holger)}
	
		\begin{figure}[h]
		\centering
		\includegraphics[width=\textwidth]{graphics/main_design.png}
		\caption{Overordnet design}
		\label{fig:main_design}
		\end{figure}
		
		Den overordnede designen er en pipeline som begynner med lys fra LEDs og ender opp med visning av en 3D-scene. Figur \ref{fig:main_design} illustrerer dette. Vi ser at alt begynner med infrarø de LEDs som er festet på hodet til brukeren. Disse sender lys som filmes av kameraet. Bildene fra kameraet leses av kode som finner punktene på bildet som senteret til hvert filmet LED. Disse koordinatene sendes til kode som bruker dem til å \space beregninge posisjonen til hodet. Denne posisjonen sendes til kode som viser en 3D-scene på skjermen, hvor synsvinkelen passer posisjonen til hodet.
	
	\subsection{Design av LED-headset}
	
		Planen for headsettet er at det skal inneholde tre dioder plassert så langt unna hverandre som mulig slik at det blir enklest mulig å skille lyspunktene fra hverandre. Vi vil ha en løsning som er grei å ha på hodet, som er portabel og lett. Vi ønsker å koble oss direkte til batteriet for å få strøm til diodene. Her trengs det en bryter for å ikke kortslutte batteriet. Diodene kobles så i parallell over batteriet i serie med hver sin motstand for å begrense strømmen.

		\begin{figure}[h]
		\centering
		%includegraphics[width=\textwidth]{graphics/circuit.png}
		\caption{Kretskjema for LED-headset}
		\label{fig:circuit}
		\end{figure}

		Vi ønsker at to av diodene står vannrett på hverandre, med en tredje diode over eller under. Vi ønsker også å kunne bytte mellom og ha en og tre dioder på om gangen for å kunne sammenligne ulike tilnærminger til problemet. Ved bare en diode på må den være synlig fra størst mulig vinkel. For at diodene skal være synlige fra størst mulig vinkel uten at hodet til brukeren kommer i veien er det ønskelig at diodene monteres langt fram på headsettet, og at den tredje dioden monteres ved mikrofonen på headsettet. 
		
	\subsection{Design av punktfinneren}
	
		Punktfinnerens oppgave er å lese bildet fra kameraet og finne koordinatene til lyspunktene til LED-ene i dette bildet. Punktfinnerens oppførsel er illustrert i figur \ref{fig:pointfinder_sequence}. Sekvensen er et eksempel på typisk oppførsel. Det starter med at finneren søker gjennom hele bildet etter punktenes koordinater (kalt kalibrering). Deretter oppdateres disse koordinatene ved å kun søke i området rundt der punktet var sist. Slik inneholder punktfinneren alltid oppdaterte punktkoordinater. Om punktene ikke finnes kan man kalibrere om igjen.
		
		\begin{figure}[h]
		\centering
		\includegraphics[width=\textwidth]{graphics/pointfinder_sequence.png}
		\caption{Sekvensdiagram for punktfinner}
		\label{fig:pointfinder_sequence}
		\end{figure}
		
		Algoritmen for søking gjennom hele bildet (kalibrering) kan utrykkes med følgende pseudokode:
		
		\begin{enumerate}
			\item Søk i linje etter linje fra topp til bunn i hele bildet etter {\it count\_limit} etterfølgende bildepunkter hvis lysintensitet (sum av rød-, grønn og blå-farge) er høyere enn minstemål {\it intensity\_cutoff}
			\item For hver slik etterfølgende rekke som finnes:
				\begin{enumerate}
					\item {\it repr} = siste av de etterfølgende bildepunktene
					\item Sjekk om {\it repr}s avstand er mer enn {\it distance\_cutoff} fra alle andre lyspunkter funnet hittil
					\item Hvis den er det, legg til {\it repr} som funnet lyspunkt
				\end{enumerate}
		\end{enumerate}
		
		Algoritmen for oppdatering av punkter som er funnet kan utrykkes med følgende pseudokode:
		
		\begin{enumerate}
			\item For hvert punkt {\it point}:
				\begin{enumerate}
					\item Søk i linje etter linje i et område med radius {\it search\_radius} rundt punktet etter {\it count\_limit} etterfølgende bildepunkter hvis lysintensitet er høyere enn minstemål {\it intensity\_cutoff}
					\item Om dette blir funnet, så er {\it point} = siste av de etterfølgende bildepunktene
				\end{enumerate}
		\end{enumerate}
	
	\subsection{Design av posisjonsfinneren og 3D-viseren (Vegar)}
	
		
	
\section{Implementasjon av løsningen}

	\subsection{Valg av kamera}
	
		Kriterier vi ser etter:
		
		\begin{itemize}
			\item Bildebrikke som kan fange opp infrarødt lys
			\item Stor nøyaktighet på avstand
			\item Støtte for live feed til en datamaskin
			\item Manuell fokus
			\item Pris
		\end{itemize}
		 
		For å få en fornuftig pris på kameraet undersøkte vi vanlige full hd (high definition) kamera. Vi så etter et kamera som fulgte standarden 1080P. Dette er en oppløsning på 1920 linjer horisontalt, 1080 linjer vertikalt, og gir høy nøyaktighet på avstand. P står for progressive. Det betyr at kameraet tar et fullt bilde i motsetning til interlaced, hvor det bare tar annenhver linje. Vi ønsker progressive for å få mindre bildebehandling enn ved interlaced. For å få live feed fra kameraet er vi avhengig av å overføre store datamenger fra kameraet til datamaskinen. Analog overføring er ikke aktuelt på grunn av kvalitetstapet i bildet. Hver kanal gir ut 1byte per piksel, og det er 3 kanaler for rød, grønn og blå. Kameraet gir ut 25 bilder i sekundet, som gir 150 USB 2.0 kan overføre opp til 480 megabit, og dette er for lite til å øverføre en ukomprimert live feed i full oppløsning. Derfor er vi avhengige av HDMI output på kameraet. En stor del av kameraene tar i bruk en 3CCD bildesensor. CCD brikkene fanger opp en del av det infrarøde spekteret i tillegg til synlig lys, derfor settes det på et infrarødt filter foran sensoren. Vi tar utgangspunkt i at vi fjerner dette filteret. Dette vil føre til at autofokusen ikke vil fungere lenger, og vi er derfor avhengig av manuell fokus. CMOS bildebrikker er et annet alternativ da disse også fanger opp infrarødt lys.
		
		\begin{figure}[h]
		\centering
		\includegraphics[width=0.40\textwidth]{graphics/hdcam.jpg}
		\caption{Panasonic HDC-SD9}
		\label{fig:hdcam}
		\end{figure}

		Valget av kamera falt til slutt på et Panasonic HDC-SD9 kamera (se figur \ref{fig:hdcam}). Dette har etter spesifikasjonene 3CCD bildesensor, HDMI utgang, manuell fokus, 1080P bilde og lav pris. Etter noe fram og tilbake fikk vi servicemanualen til kameraet fra Panasonic. Den beskriver trinnvis hvordan IR-filteret kan fjernes. Vi fikk fjernet IR-filteret, men det viste seg at manuell fokus ikke fungerte som forventet. Det var en automatisert funksjon som sto for fokuset, slik at dette ikke kunne stilles inn riktig uten filteret. Optimalt burde vi erstattet filteret med en glassbit, men vi valgte å erstatte filteret med gjennomsiktig pvc plast, slik at lysbrytningen skulle ligne på den gjennom IR-filteret. De optiske egenskapene til plasten er ikke spesielt bra, men vi ender likevel opp med et mye bedre bilde på grunn av at bildet ikke lenger er like langt ute av fokus. For vår applikasjon er dette bildet mer enn nok til å tracke IR lys i rommet. For å lettere kunne tracke lyset fra dioden har vi tatt i bruk et filter som blokkerer alt lys utenom infrarødt. REF: (OPTIR 1.0 NG 305 X 100 fra Instrument Plastics. Kjøpt via http://www.farnell.com (varenr 177143))
		
	\subsection{Konstruksjon av LED-headset}
		
		Kriterier vi så etter:
	
		\begin{itemize}
			\item Lett å bruke
			\item Liten vekt
			\item Minst mulig i veien
			\item Høy intensitet på lyset
		\end{itemize}

		Målet var å finne en løsning som ikke er i veien for brukeren. Optimalt sett såtrenger ikke brukeren ta på seg noe ekstra utstyr. For å kunne tracke brukeren trengs det minimum to lyskilder og 1 kamera, eller to kamera og en lyskilde. Vi bestemte oss for å bruke et trådløst headset, da dette ikke er spesielt tungvindt å ha på. Dette har også et innebygd batteri som vi kan koble lyskilder på. For å kunne skille rotasjon fra avstand trengs det en tredje diode. Denne kan festes på mikrofonen.
		
		\begin{figure}[h]
		\centering
		\includegraphics[width=0.4\textwidth]{graphics/headset.jpg}
		\caption{Logitech Clearchat}
		\label{fig:headset}
		\end{figure}

		Vi gikk til innkjøp av et Logitech Clearchat trådløst headset (seg figur \ref{fig:headset}, og 3 IR dioder (SFH 415) med høy intensitet. IR diodene var spesifisert til å tåle opp mot 1 Ampere. Batteriet påheadsettet gir ut 3,7V. Målet var å få mest mulig intensitet ut, slik at lyset er synlig lengst mulig bort, og slik at dioden ikke trenger peke direkte påkameraet for å kunne registreres. Diodene vil fungere som en kortslutning om de festes rett påbatteriet, så for å begrense strømmen gjennom dem trengs det motstand i serie. Vi dimensjonerte oppsettet, med en motstand på 47? foran dioden, slik at det går under 100mA gjennom hver diode. Det er også koblet opp en bryter med tre innstillinger for å kunne bytte mellom at 2 dioder lyser, og 1 diode. Vi har bestemt oss for å bruke en diode for tracking med wii-remotes, og to dioder ved bruk av hd kamera istedenfor tre.

		Det viste seg at kameraet klarte å detektere diodene bedre enn forventet, som gjør at diodestrømmen er kraftig overdimensjonert, noe som da trekker mer strøm fra batteriet til headsettet enn nødvendig.
		
	\subsection{Tilkobling av kamera til PC}
	
		Kameraet er koblet til PC-en gjennom en HDMI-kabel. Denne kabelen er festet til et Intensity-kort som er installert i PC-kabinettet.
	
	\subsection{Implementasjon av programvaren}
	
		Progamvaren består av punktfinneren, posisjonsfinneren og 3D-viseren. De er alle skrevet i Java, men 3D-viseren bruker et bibliotek implementert i C for selve visning av 3D-grafikken. I denne seksjonen kommer vi til å presentere hvordan programvaren i løsningen er strukturert.
		
		\subsubsection{Punktfinneren (Holger)}
		
			Figur \ref{fig:holger_class_diagram} viser et klassediagram av punktfinneren. CameraHeadTracker (CHT) er den viktigste klassen. Det er denne som tilbyr punktfinne-funksjonaliteten ovenfor resten av systemet. Denne arver fra SingleSourceHeadTracker, som igjen arver fra HeadTracker. CHT bruker TrackingUtil for å gjøre oppgaven sin, og inneholder TrackedPoint-instanser for punktene som spores. TrackingUtil tilbyr nyttefulle funksjoner i forbindelse med finning og sporing av punkter.
			
			CHT inneholder også et graphical user interface (GUI) gjennom CameraHeadTrackerGUI. Dette et er et enkelt GUI som viser bildet fra kameraet og "p" holdes på tastaturet, og gir mulighet for finne alle punktene på nytt ved å taste mellomrom. Dette GUI-et inneholder to instanser av lyttere for å lytte etter disse tastetrykkene. Disse er CalibrateKeyListener og ShowCamKeyListener.
		
			\begin{figure}[ht]
			\centering
			\includegraphics[width=\textwidth]{graphics/holger_class_diagram.png}
			\caption{Klassediagram for punktfinneren}
			\label{fig:holger_class_diagram}
			\end{figure}
		
		\subsubsection{Posisjonsfinneren og 3D-viseren (Vegar)}
		
			Figur \ref{fig:vegar_class_diagram} viser et klassediagram av posisjonsfinneren og 3D-viseren.
		
			\begin{figure}[h]
			\centering
			%\includegraphics[width=\textwidth]{graphics/vegar_class_diagram.png}
			\caption{Klassediagram for posisjonsfinneren og 3D-viseren}
			\label{fig:vegar_class_diagram}
			\end{figure}
			
			%TODO: Lag og beskriv klassediagrammet
			
		\subsubsection{Biblioteker brukt i implementasjonen}
			
			DirectShow brukes for å hente bildene fra HD-kameraet. For å bruke dette i Java tok vi i bruk en DirectShow Java wrapper kalt dsj. Dette er et Java-bibliotek (jar-fil) med tilhørende maskinkode (dll-fil) som gjør DirectShow tilgjengelig gjennom et grensesnitt i Java. Dette grensesnittet er enklere å bruke enn det opprinnelige DirectShow-grensesnittet, som er notorisk for sin kompleksitet.
			
			For å vise 3D-scener på skjermen brukes OpenGL. Dette er et bibliotek for å tegne 2 og 3-dimensjonelle figurer, og bruker datamaskinens skjermkort for akselerasjon av den prosessen. For å gjøre OpenGL tilgjengelig i Java bruker vi en wrapper kalt Java OpenGL (JOGL). Dette gjør at maskinkoden i OpenGL kan kjøres fra Java.
			
			Wiimotesene kommuniserer gjennom Bluetooth-nettverk. For å snakke med disse bruker vi et Java-bibliotek kalt BlueCove. Dette tilbyr et grensesnitt for å sende og ta imot melding gjennom Bluetooth.
		
		\subsubsection{Kjørbar distribusjon (Vegar)}
		
			%TODO: Legg til tekst om JAR-filen vi har laget, og eventuelle andre filer som må være med en distribusjon